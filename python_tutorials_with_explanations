"""here i am creating custom code snippet so whenever i create a python file python automatically insert %##
its we are doing because i want to run code seperetly not whole script every time
there are some shortcuts in  pycharm but it gives whole output of script
Go to File ‚Üí Settings ‚Üí Editor ‚Üí File and Code Templates
Select Python Script
Add this at the top of the template:
#%%
Click Apply ‚Üí OK
‚úî Now every new Python file you create will automatically start with a #%% cell."""


#%%
print("python is fun!"); print("learning python is fun!"); print("python is fun!")

#%%
x = 10
y = 20
print(x + y)

#%%
print("This is another block")
# First we we write our first program
print("Hello, Word!")

#Python Indentation(spaces at the begenning of writing code):uses indentation to use block code
#the number of code is upto you as programmer ,the most common use is 4 but it has to be at least 1"""

if 5> 2:
    print("Five is greater than two!")
if 5 > 2:
         print("Five is greater than two!")
# you have to use same number of spaces in the same block of code otherwise there will be error
if 5 > 2:
    print("Five is greater than two!")
          print("Five is greater than two!")

# STATEMENTS: means programming instructions
#%%
print("python is fun!") # python is fun is statement or our instructin
print("learning python is fun!")
print("python is easy to learn!") # python can contains many statement and it execeted one by one

#SEMICOLON(OPTIONAL,RARELY USED)
# pycharm supports cell execution using this symbol #%%

%%
print("python is fun!"); print("learning python is fun!"); print("python is fun!")

#%%
x = 10
y = 20
print(x + y)

#%%
print("This is another block")

# %%
#python  Variables: in python ,wariables are created when u assign value to it
x=5
y="Hi"

#%%
print("HI , world")
print("python is fun!", end=" ")
# the cursor stays on the same line, after this space in output

#%%
print("I am",35,"years old")
#mix text and numbers

#%%
#CASTING: if you want to specify the data type of a variable  this can be done by casting

x =str(3) #'3'
y =int(3)
z =float(3)
print(x , y ,z)

#%%
x = 5
y = "vedanti"
print(type(x))
print(type(y))
# in this we can find data type of any variable here int and str

#%%
a = 4
A = "salary"
"variable names are case sensitive A will not overwrite a"

#%%
#multi word variable names: 3 techniques:1.camel case,2.pascalcase,3.snake case
#Camel Case
#Each word, except the first, starts with a capital letter:

myVariableName = "John"
#Pascal Case
#Each word starts with a capital letter:
MyVariableName = "John"
#Snake Case
#Each word is separated by an underscore character:
my_variable_name = "John"

#%%
# assign multiple value  to variables
x,y,z = 1, "orange", 3 #assign many values to  multiple variables at a time
print(x)
print(y)
print(z)

x=y=z = "orange" # assign one value to multiple variables
print(x)
print(y)
print(z)

#%%
#UNPACK COLLECTION: if we have a collection values like list,tuple,etc
#pythion allows you to extract collection values into variables called unpacking

fruits = ["apple", "banana", "cherry"]
x , y, z = fruits
print(x)
print(y)
print(z)

#%%
#output function print()
x ="python"
y ="is"
z ="Awesome"
print(x,y,z)

# we can also use + operator to output multiple variables
x ="python " # here we use space after each variable
y ="is "
z ="Awesome "
print(x+y+z) #output: python is Awsome if no space used then output:pythonisAwsome

x=3
y=6
print(x+y) # + act as mathematical operator

#%%
#GLOBAL AND LOCAL VARIABLES
#GLOBAL VARIABLES: the variables are created outside the function is called Global variables
#it can be used both inside of function and outside
x = "awesome"
def my_function():
    print("python is "+x)
my_function()

# if we create a variable with samae name and different value inside the function is considered as LOCAL variable
# in this when we call function it will consider local functin
x = "Awesome"
def my_function():
    x = "fantastic"
    print("python is " + x)
my_function()
#output:python is fantastic

#to create golobal variable inside the functin use global word

x = "Awesome"
def my_function():
    global x
    x = "fantastic"
    print("python is " + x)
my_function()

def myfunc():
  global x
  x = "fantastic"
myfunc()
print("Python is " + x)

#%%
#DATATYPES
#STRINGS: strings as array, find charecter at 1 position
 a = "Hello, World!"
 print(a[1]) #counting will start from 0 even comma and space also includes

#looping through string
for x in "Vedanti":
    print(x) # in output letters will present vertically one by one

#string length
a = "Hello, World!"
print(len(a)) #in output 13 will come spaces and comma includes

#CHECK STRING
#to check certain charecterv present in string or not use keyword 'in'

a = "Vedanti is a good Girl "
print("Vedanti" in a) # output:TRUE

#USE IT IN "IF" statement
if "Vedanti" in a: # in if statement words are case sensitive
    print("yes,'Vedanti' is present")

#check if not using 'NOT IN' keyword
print("Vedashree" not in a)
# use not in  if statement
if "Vedashree" not in a:
    print("NO")

#%%Slicing strings:
#specify start index(index means number starts from 0-.. for string) and end index seperated by colon to return part of string

#return range of charecters using slice syntax(remember to count from 0)
a = "Vedanti is a good Girl"
print(a[2:5]) #dan it includes 2nd index but not 5th if want  2 to 4 index then = [2:5] its easy way to remember
print(a[-6:-2]) # d Gi same as[6:2] only it reads from back but includes

#slice from the start
print(a[:9]) #vedanti i prints means 9th index not includes
print(a[:-9])

#slice to the end
print(a[2:]) # 2nd index include(o/p:danti is a good Girl )
print(a[-2:])

#NEGATIVE INDEXING: use to start slice from the end index
#ex: get the charecter 'o' from "world" = [-5]

print(a[-6:-2]) # same as[6:2] only it reads from back but includes 6th index and not 2nd

#%%
#MODIFY STRINGS: python has some built in methods we can use on string

a = " Vedashree is a good Girl "

#UPPERCASE(). : METHOD RETURNS THE STRING IN UPPERCASE
print(a.upper()) # o/p:VEDASHREE IS A GOOD GIRL
print(a.lower()) # vedashree is a good girl

# REMOVE WHITE SPACES
# strip() remove any white spaces at the begenning or at the end
print(a.strip()) # removes space only at the beggening at at the end of string inside " "
print(a.rstrip()) # removes space from right side of string not inside the string sentence means not space between words
print(a.lstrip()) # removes space from leftside

#REPLACE(): REPLACE STRING WITH ANOTHER STRING
print(a.replace('G','O'))
print(a.replace('girl','boy'))
print(a.replace(' ','a'))

#SPLIT: Returns a list where text between seperator(,) becomes list items
print(a.split()) #['Vedashree', 'is', 'a', 'good', 'Girl']
print(a.split(",")) # [' Vedashree is a good Girl ']

#OTHER METHODS
a="i like to go to the school, Anshuta is my best friend"
print(a.capitalize())
print(a.casefold())
print(a.center())
print(a.count())
print(a.encode())
print(a.endswith()
print(a.expandtabs())
print(a.find())
print(a.format())
print(a.format_map())
print(a.index())
print(a.isalnum())
print(a.isalpha())
print(a.isnumeric())
print(a.isdigit())
print(a.islower())
print(a.isspace())
print(a.istitle())
print(a.isupper())
print(a.isprintable())
print(a.title())
print(a.swapcase())
print(a.join())
print(a.ljust())
print(a.rjust())
print(a.rfind())
print(a.rsplit())
print(a.splitlines())
print(a.replace(" ",""))
print(a.startswith("i"))
print(a.endswith("i"))
print(a.swapcase())
print(a.title())
print(a.zfill())


#%%
#STRING CONCATENATION: (COMBINE TWO STRINGS USING  + OPERATOR)
a = "vedanti"
b = "vedashree"
c = a + b
print(c) #vedantivedashree use space in string then it will use space
print(a+b) #vedantivedashree

# to add space between them use space in first string or " "
print(a +' '+ b)

#%%
# to combine string and number we can use  format() method or f string its introduce in python 3.6
age = 9
txt = f"my name is vedanti, i am {age}"
print(txt)

#placeholder{ } it can contains:variables,functions nd operators
char = "smart"
txt = f"my name is vedanti, i am {char} girl"
print(txt)

# display value with two decimals
price = 59
txt = f"the price is {price:2f} dollors"
print(txt)

# math oprtations in placeholder
txt = f"the price is {20 * 40} dollors" # use space is and spaceholder
print(txt) #the price is 800 dollors if space not used: the price is800 dollors

#%%
#ESCAPE CHARECTER: for next line \n , \"vedanti\" for adding double quoted string inside " " string
txt = "hello, \"world\"" # o/p: hello, "world"
txt = "hello, \\world" # hello, \world
txt = "hello, \nworld" #hello,  world in next or new line
txt = "hello, \rworld"
print(txt)

#%%
print(10 > 9)
print(10 == 9)
print(10 < 9)

a = 200
b = 50
if b > a:
    print("b is greater than a")
else:
    print("b is not greater than a")

#%%
print(bool("Hello")) # caps 'p for print will show error'
print(bool(15))

x = "Hello"
y = 15

print(bool(x))
print(bool(y))

# in boolean most values are tre except :
# 1. any number is TRUE except 0
# 2. any set list,tuple and dict is True except empty one

#TRUE
a=bool("abc")
b=bool(123)
c=bool(["apple", "cherry", "banana"])
print(a,b,c)
#FALSE
d=bool(False)
e=bool(None)
f=bool(0)
g=bool("") # if we use space in string then it will be true(" ")
h=bool([ ])
i=bool(( ))
j=bool({ })
print(d,e,f,g,h,i,j)

#%%
# the ob ject that is made from class with a _len_  function that returns o or falseclass myclass():

class myclass():
  def __len__(self):
    return 0

myobj = myclass()
print(bool(myobj))

#%%
# casn create functin that returns boolean value
def myfunction():
  return True
print (myfunction())

#%%
#print YES if functin returns True otherwise None
def myfunctin():
    return True# True & False always start with caps otherwise shows error
if myfunction():
  print("yes")
else:
  print("no")
##################################################################

#PYTHON OPERATORS
'''
1.ARITHMATIC OPERATORS : +,-,*,%,/,**:exponentiation(x**y),//:floor division(x//y)
2.ASSIGNMENT OPERATORS : use to assign values(==,+=,-=,*=,/=,%=,//=,**=,&=,\=,:=)
3.COMPARISION OPERATORS: compare two values(==,!=,>,<,>=,<=)
4.DIVISION OPERATORS:
5.LOGICAL OPERATORS: and , or, not
6.IDENTITY OPERATORS: is, is not(Identity starts from I: is also start from i just Hint to remember)
7.MEMBERSHIP OPERATORS:in , not in(Hint: if we have to become member first we need to become one IN them)
8.BITWISE OPERATORS:(& -AND,| -OR, ^ - XOR, ~ - NOT, << -ZERO FILL LEFT SHIFT,>> -SIGNED RIGHT SHIFT
9.MODULE OPERATORS : % ex: print(a % b)
'''

#%%
#1.Aruthmatric operators
x=15
y=4

print(x+y) :19
print(x-y) :11
print(x*y) :60
print(x/y) :3.75
print(x//y):3
print(x%y) :3
print(x**y):50625(15**4:15*15*15*15)

#%%
#2.ASSIGNMENT OPERATORS:
'''
Python 3.8 introduced the := operator, known as the "walrus operator". It assigns values to variables as part of 
a larger expression:
# üìù **Short Notes: Walrus Operator (:=) vs Assignment (=) ‚Äî Interview Answer**
### **1. What is the Walrus Operator?**
The **walrus operator (`:=`)** in Python 3.8+ allows **assignment inside expressions**.
It lets you assign a value *and* use it immediately within the same line.
---
# üÜö **Difference Between `:=` and `=`**

| Feature              | `=` (Assignment Operator)    | `:=` (Walrus Operator)                        |
| -------------------- | ---------------------------- | --------------------------------------------- |
| Purpose              | Assigns value to variable    | Assigns value **within** an expression        |
| Where it can be used | Only as a separate statement | Inside conditions, loops, list comprehensions |
| Expression allowed?  | ‚ùå No                         | ‚úîÔ∏è Yes                                        |
| Introduced in        | Old versions                 | Python 3.8+ 
                                  
# üß† **Simple Explanation**
* `=` assigns a value normally:
  x = 5

* `:=` assigns a value while evaluating a condition or expression:
'''

#%%
if (x := 5) > 3:
  print(x)

'''# üü¢ **Example 1: IF Condition**

### Without Walrus:
n = len(items)
if n > 3:
  print(n)
    
### With Walrus:
if (n := len(items)) > 3:
    print(n)
'''
''''**Benefit:** `len(items)` is called once and code becomes shorter.
**Benefit:** Cleaner loop, no repeated input call.
**Benefit:** Cleaner, more Pythonic
---
# üéØ **When to Use Walrus Operator**

* When you want **less repetition**
* When you want **cleaner loops or conditions**
* When calculating a value only once is more efficient
---
# üéØ **When NOT to Use**
* When it reduces readability
* For very simple assignments (not inside expressions)
# ‚≠ê **One-line Interview Definition**
> ‚ÄúThe walrus operator (`:=`) allows assignment inside expressions. It is used to assign and use a value in the same line, 
especially in conditions and loops, making the code shorter and more efficient.'''

# %%
#3.COMPARISION  OPERATOR

x = 5
y = 3

print(x == y) # False
print(x != y)
print(x > y)
print(x < y)
print(x >= y)
print(x <= y)

#%%
#Chaining comparitor oprtator:allows you to chain comparitor operator

x = 5

print(1 < x < 10) # True
print(1 < x and x < 10) # True

#%%
# 3.PYTHON LOGICAL OPERATORS
#AND: RETURNS TRUE IF BOTH STATEMENTS TRUE
#test if number is greater than zero and less than 10
x = 5
print(x > 0 and x <10) #True, and and or should be lowercase

#OR : returns true if one of the statement is true
#test if number is less than 5 or greater than 10

x = 5
print(x < 5 or x > 10) #False

#not: Reverse the result with not
x = 5
print(not(x > 3 and x < 10))

#%%
#4.IDENTITY OPERATORS: is ,is not: used to compare the objects, not if they are equal
# is: returns true if both variables are the same object,
# is not: returns true if both variables are not the same object
#here is , is not  doesn't check values it checks memory location i.e objects in memory location

x =["apple","banana"] # it stores at memory A
y =["apple","banana"] # it stores at memory B
z = x                 # it stores at memory A as z=x
print(x is y) #False
print(x is z) #True: memory locations are same
print(x==y)   #True : (== : checks value)
print(x is not y)

#%%
#MEMBERSHIP OPERATORS: in , not in
#in : returns true if sequence with specified value is present in the object
#not in: returns true if sequence with specified value is not present in the object
x =["apple","banana"]
print("banana" in x) # T
print("pineapple" in x) # F
print("pineapple" not in x) #T

text = "Hello World"

print("H" in text) # T
print("hello" in text) # F
print("z" not in text) # T

#Operator Precedence (KANCHBHAGUBEV: In MARATHI MATHS) , parentheses has highest precedence
print(100 + 5 * 3)
print((6 + 3) - (6 + 3))

#%%
#LIST: list are used to stora multiple items in single variable
# it's one of 4-built in data types in python used to store collection of data
# 4
# -built in/collection datatypes: LIST,TUPLE,SET,DICTIONARY
#defination:list items are odered,changable, and allow duplicate values
'''
There are four collection data types in the Python programming language:

List: is a collection which is ordered and changeable. Allows duplicate members.
Tuple:is a collection which is ordered and unchangeable. Allows duplicate members.
Set: is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.
Dictionary:  is a collection which is ordered and changeable. No duplicate members.
*Set items are unchangeable, but you can remove and/or add items whenever you like.
**As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.
'''
list1 =["apple",1,2.3,("hi"),{"vedanti"}] # o/p:['apple', 1, 2.3, 'hi', {'vedanti'}]
list = ["apple",1,2.3,("hi",2),{"vedanti"}] # o/p:['apple', 1, 2.3, ('hi', 2), {'vedanti'}]
print(list1)

#%%
#LIST METHODS
# access list items : items are indexed we can access by referring to the index number
list = ["apple","banana","cherry"]
print(list[0]) # o/p: apple
print(list[-1])#cherry (in negative indexing no 0 index direct starts from -1)

#slicing of list or range of indexes (same rule everyewhere [x:y] value before : included and value after : excluded)
list1 = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]
print(list1[2:5]) #['cherry', 'orange', 'kiwi']
print(list1[2:]) #['cherry', 'orange', 'kiwi', 'melon', 'mango']
print(list1[:2]) #['apple', 'banana']
print(list1[-4:-1])#['orange', 'kiwi', 'melon']

# check if item exists
 list2  = ["apple", "banana", "cherry"]
 if "apple" in list2:
     print("yes, 'apple' is present" )

#%%
#change list items

list3 = ["apple", "banana", "cherry"]
list3[1]="grape"
print(list3) #['apple', 'grape', 'cherry']

#change range of item values

list3 = ["apple", "banana", "cherry"]
#list3[1:2] = ["grape"] #o/p :['apple', 'grape', 'cherry']
#list3[0:1] =["grape"] # ['grape', 'banana', 'cherry']
#list3[0:1] = ["grape","kiwi","melon"] #['grape', 'kiwi', 'melon', 'banana', 'cherry'] if we add extra items then order will change

#change the second value(not index remember) by replacing two new values
#list3[1:2]=["kiwi","melon"] #['apple', 'kiwi', 'melon', 'cherry']
#list3[2] =["kivi","melon"] # ['apple', 'banana', ['kivi', 'melon']]
#list3[0:3] ="kiwi" #['k', 'i', 'w', 'i']
#[0:3] =["kiwi"] #['kiwi']
#list3[0:4] # no output
#list3[0:2] ="kiwi"  #['k', 'i', 'w', 'i', 'cherry']
list3[0:2] =["kiwi"] #['kiwi', 'cherry']
print(list3) #
#Note: The length of the list will change when the number of items inserted does not match the number of items replaced.

#%%
#INSERT ITEMS: to insert new item without replacing any existing values and at specified index this method can use
#list4 = ["apple", "banana", "cherry"]
#list4.insert(2,"orange") # ['apple', 'banana', 'orange', 'cherry']  2: at second index

#APPEND ITESMS: to add item to the end of the list
#list4.append("grape") #['apple', 'banana', 'cherry', 'grape']
#list4.append(["kiwi","melon"]) # ['apple', 'banana', 'cherry', ['kiwi', 'melon']] it will take exactly 1 argument

#EXTEND LIST: to append elements from another list to current list
list4 = ["apple", "banana", "cherry"]
#list5 = ["kiwi", "melon", "grapes"]
list6 = ("kiwi", "melon", "grapes") #tuple
#list4.extend(list5) #['apple', 'banana', 'cherry', 'kiwi', 'melon', 'grapes']

#ADD ANY ITERABLE:WE CAN ADD TUPLE,SET,DICT etc, any iterable objects
#list4.extend(list6) #['apple', 'banana', 'cherry', 'kiwi', 'melon', 'grapes']
#print(list4)

#%%
#REMOVE LIST ITEMS:remove() method removes items
listA = ["apple", "banana", "cherry","banana"]
#listA.remove("apple") #['banana', 'cherry'] all method names should be in lowercase

#if there are duplicate values or items it will remove 1st one
#listA.remove("banana")  #['apple', 'cherry', 'banana']

#Remove specified index pop() method
#listA.pop(1) #['apple', 'cherry', 'banana'] :removes first index item no need [] for index

#if we do not specify index pop method removes last item
#listA.pop() #['apple', 'banana', 'cherry']

#the del keyword also removes specified index
#del listA[0] # syntax is different even [] needs to use for mentioned index
            #['banana', 'cherry', 'banana']
#print(listA)

#del keyword can delete list completely
listb=["kiwi",1,2,4]
#del listb # o/p  no result

#CLEAR METHOD: empties the list,list still remains but it has no content

listb.clear() # o/p: []
print(listb)

#%%
#PYTHON LOOP LISTS
#WE CAN LOOP THROUGH LIST : print all items in list one by one
#list = ["apple", "banana", "cherry"]
#for x in list: # x is the loop variable, it takes 1 element from the list at time during esch iteration
#    print(x) # it will print list items one by one

#loop through the index numbers use range() and len()
#list = ["apple", "banana", "cherry"]
#for i in range(len(list)): # o/p:apple banana cherry one by one
#    print(list[i]) # i should be in [] as it is index
'''
Here, i represents the index of the list.
We use range(len(list)) to loop through each index, and then use list[i] to access the item at that index.
üí° When do we use this method?
We use for i in range(len(list)): when we need:
‚úî index number
‚úî index-based operations
‚úî modifying list values by index
'''
#%%
#USING WHILE LOOP:
list =["apple","banana","cherry"] #o/p: one by one apple banana cherry
i = 0 #starts with index 0
while i < (len(list)): #loop will continue as long as i is less than len(list):0<3
    print(list[i]) #list consists of names and i consists of index number
    i=i+1 # to increase i by 1 after each loop(0-1-2-3) ,when i becomes 3 ,condition i<3 becomes false and loop stops

#%%
#LOOPING USING LIST COMPREHENSION

list = ["apple", "banana", "cherry"]
[print(x) for x in list]

#%%
# LIST COMPPREHENSION: IT offers shorter syntax when u want to create new list based on the values of existing list
# eg; based on fruits list if we want name of fruits with letter "a" in the name
fruits = ["apple", "banana", "cherry"]
#%%
# with list compression we can do it in only one line(always use [] to write code in list compherension)
fruits = ["apple", "banana", "cherry"]
newlistA= [x for x in fruits if "a" in x]
print(newlistA) #['apple', 'banana']

#SYNTAX FOR LIST COMPHERENSION:(expression:x, item:x,iterable:fruits,condition:"a" in x)
#newlist = [expression for item in iterable if condition == True)
newlist1= [x for x in fruits if x != "apple"]# only accept items that are not "apple"
print(newlist1) #['banana', 'cherry']

#ITERABLE: ITERABLE CAN BE ANY OBJECT LIKE LIST, TUPLE ,SET
#WE CAN USE RANGE() FUNCTION TO CREATE ITERABLE

list =[x for x in range(10)]
print(list) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

list1 =[x for x in range(10) if x<5] #same ex like above only condition applied
print(list1) #[0, 1, 2, 3, 4]

#The expression is the current item in the iteration, but it is also the outcome, which you can manipulate before it ends up like a list item in the new list:
#set the values in thw new list to uppercase
newlist2= [x.upper() for x in fruits]
print(newlist2) #['APPLE', 'BANANA', 'CHERRY']

#set all values in newlist to "hellow"

newlistB =['HELLO' for x in fruits]
print(newlistB) #['HELLO', 'HELLO', 'HELLO']

#The expression can also contain conditions, not like a filter, but as a way to manipulate the outcome:

nwelisiC = [ x if x != "banana" else "orange" for x in fruits] #['apple', 'orange', 'cherry']
print(nwelisiC) #"Return the item if it is not banana, if it is banana return orange".

# without lisi comprehension same output as 1st example

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []

for x in fruits:
  if "a" in x:
    newlist.append(x)

print(newlist)
#%%
#SORT LIST:Sort list alphanumerically ascending by default

list = ["apple", "banana", "cherry", "kiwi", "mango"]
list.sort() #['apple', 'banana', 'cherry', 'kiwi', 'mango']
print(list)

list1 = [1,8,3,5,2,6,4,9.7,4.5]
list1.sort() #[1, 2, 3, 4, 4.5, 5, 6, 8, 9.7] ,in ascending order by default
print(list1)

#SORT DESCENDING
list.sort(reverse=True)  #['mango', 'kiwi', 'cherry', 'banana', 'apple']
list1.sort(reverse = True) #[9.7, 8, 6, 5, 4.5, 4, 3, 2, 1]
print(list1)
print(list)

# CASE SENSITIVE SORT : can give unexpected result
thislist = ["banana", "Orange", "Kiwi", "cherry"]
thislist.sort() #['Kiwi', 'Orange', 'banana', 'cherry']
print(thislist)

# luckily we can use built in key function when sorting list,
#SO IF U WANT CASE INSANSITIVE SORT FUNCTION ,USE str.lower as a key function

thislist1 =["banana", "Orange", "Kiwi", "cherry"]
thislist1.sort(key = str.lower) #['banana', 'cherry', 'Kiwi', 'Orange']
print(thislist1)

# REVERSE ORDER: if want to reverse order of list , regardless of the alphabet
thislist2 =["banana", "Orange", "Kiwi", "cherry"]
thislist2.reverse() #['cherry', 'Kiwi', 'Orange', 'banana']
print(thislist2)

#%%
#COPY A LIST:

list = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist =list.copy() #['apple', 'banana', 'cherry', 'kiwi', 'mango']
print(newlist)
'''
thislist = ["apple", "banana", "cherry"]
mylist = list(thislist)
print(mylist)'''

#SLICE METHOD: we can also use slice method to make a copy of list

list1 =["apple", "banana", "cherry", "kiwi", "mango"]
newlist1 = list1[:] #['apple', 'banana', 'cherry', 'kiwi', 'mango']
print(newlist1)
#%%
#JOIN LISTS:
# one of the easiest ways are by using the + operator

list1 = ["apple", "banana", "cherry", "kiwi", "mango"]
list2 = [1,2,3,4,5,6]
list3 = list1 + list2
print(list3) #['apple', 'banana', 'cherry', 'kiwi', 'mango', 1, 2, 3, 4, 5, 6]

# another way to join two lists is by appending all the items from list 2 to list1

for x in list2:
  list1.append(x)
print(list1) #['apple', 'banana', 'cherry', 'kiwi', 'mango', 1, 2, 3, 4, 5, 6]

# extend() method to add list2 at the end of list1
list1.extend(list2)
print(list1) #['apple', 'banana', 'cherry', 'kiwi', 'mango', 1, 2, 3, 4, 5, 6]

#%%
#Tuple:used to store multiple items in a single variable,it's ordered, UNCHANGABLE, allows duplicate
tuple = ("apple", "banana", "cherry", "kiwi", "mango")
print(tuple) #('apple', 'banana', 'cherry', 'kiwi', 'mango')
#Unchangable: means we cannot add ,remove or change items after the tuple has been created
print(len(tuple)) # 5
tuple1= ("apple",) # to create tuple with 1 item u have to add comma after the item
print(tuple1)#('apple',)

tuple3 =("apple","banana",1,23,4,True,False)  #('apple', 'banana', 1, 23, 4, True, False)
print(tuple3)
print(type(tuple3)) #<class 'tuple'>
tupleA = (("apple", "banana", "cherry", "kiwi", "mango"))
print(tupleA) #tuple counstructor: ('apple', 'banana', 'cherry', 'kiwi', 'mango')

#%%
#access tuple: we can access tuple using index number same as list
tuple=(("apple", "banana", "cherry", "kiwi", "mango"))
print(tuple[1]) #banana
print(tuple[ 2:4]) #('cherry', 'kiwi')
print(tuple[:3]) #('apple', 'banana', 'cherry')
print(tuple[3:]) #('kiwi', 'mango')
print(tuple[:]) #('apple', 'banana', 'cherry', 'kiwi', 'mango')
print(tuple[-1])#mango
print(tuple[-2:-4]) #()
print(tuple[-2:]) #('kiwi', 'mango')
print(tuple[:-2]) #('apple', 'banana', 'cherry')

#%%
#UPDATE TUPLES: tuple is unchangable that means we can't add remove or change items once the tuple is created
#change tuple values: we can't directly change but we can convert tuple into list then change value, add or remove# and again convert into tuple
#and again convrt it into tuple this way we can change add remove items
#in this way all methods used in list we can apply for tuple also
del tuple
x = ("apple", "banana", "cherry", "kiwi", "mango")
y = list(x) #['appl  , 'banana', 'cherry', 'kiwi', 'mango']
print(y)
y[1] = "melon" #['apple', 'melon', 'cherry', 'kiwi', 'mango']
print(y)
x = tuple(y) #('apple', 'melon', 'cherry', 'kiwi', 'mango')
print(x)
#%%
# ADD ITEMS:
thistuple = ("apple", "banana", "cherry")
y = list(thistuple)
y.append("orange")
thistuple = tuple(y)
print(thistuple) #('apple', 'banana', 'cherry', 'orange')

#create a new tuple with vlaue "orange" and add that tuple
thistuple1= ("apple", "banana", "cherry")
y = ("orange",)
x = thistuple1 + y
print(x) # ('apple', 'banana', 'cherry', 'orange')

#REMOVE ITEMS:
thistuple2= ("apple", "banana", "cherry")
y = list(thistuple2)
y.remove("apple")
thistuple2= tuple(y)
print(thistuple2) #('banana', 'cherry')

#DELETE TUPLE:
thistuple3= ("apple", "banana", "cherry")
del thistuple3
print(thistuple3) # shows error as tuple deleted

#%%
#UNPACKING A TUPLE: we allowed to extract the values back into variables is called unpacking
#PACKING: when we create a tuple we normally assigns value to it is called "packing" a tuple
'''
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
(green, yellow, red,brown,orange) = fruits
print(green)
print(yellow)
print(red)
print(brown)
print(orange) #applre banana cherry kiwi mango one by one'''
'''
fruits1= ["apple", "banana", "cherry", "kiwi", "mango"]
(green, yellow, red,brown,yellow) = fruits1
print(green)
print(yellow)
print(red)
print(brown)
print(yellow) # apple mango cherry kiwi mango (dont know why banana not added to 1 yellow color)
#yellow = "banana"  ‚Üí replaced by ‚Üí yellow = "mango" , it will overwrite the first value, so you lose "banana".
print(red)
print(brown)'''

#%%
#USING ASTERISK* :
#if the number of varibles less than the number of values u can add an * to the variable name and value will be assigned to the variable
fruits = ("apple", "banana", "cherry", "strawberry", "raspberry")

(green , yellow , *red)= fruits

print(green)
print(yellow)
print(red) # apple banana ['cherry', 'strawberry', 'raspberry'] one by one

#%%
# if asterisk added to middle variable instead last one then
fruits = ("apple", "mango", "papaya", "pineapple", "cherry")

(green, *tropic, red) = fruits

print(green)
print(tropic)
print(red) # apple ['mango', 'papaya', 'pineapple'] cherry one by one

#%%
#LOOPS THROUGH TUPLES
tuple = ("apple", "banana", "cherry")
for x in tuple:
print(x) # apple banana cherry one by one

tuple1 = ("apple", "banana", "cherry")
for i in range(len(tuple1)):
print(tuple1[i])
#%%
tuple3= ("apple", "banana", "cherry")
i=0
while i < len(tuple3):
print(tuple3[i])
i=i+1

#%%
#JOIN TUPLES :
tuple1 = ("a", "b" , "c")
tuple2 = (1, 2, 3)

tuple3 = tuple1 + tuple2
print(tuple3) #('a', 'b', 'c', 1, 2, 3)
# MULTIPY TUPLES
fruits = ("apple", "banana", "cherry")
mytuple = fruits * 2

print(mytuple) #('apple', 'banana', 'cherry', 'apple', 'banana', 'cherry')

#%%
#COUNT:
fruits = ("apple", "banana", "cherry", "apple", "mango", "apple")
print(fruits.count("apple")) #3

#INDEX;
fruits = ("apple", "banana", "cherry", "apple", "mango")
print(fruits.index("cherry")) #2

#%% A set is a collection which is unordered, unchangeable*, and unindexed.
#SET:* Note: Set items are unchangeable, but you can remove items and add new items.
myset = {"apple", "banana", "cherry"}
print(myset)  #{'cherry', 'apple', 'banana'}
#Note: Sets are unordered, so you cannot be sure in which order the items will appear.
#Once a set is created, you cannot change its items, but you can remove items and add new items.
#Set items can appear in a different order every time you use them, and cannot be referred to by index or key.

thisset = {"apple", "banana", "cherry", "apple"}
print(thisset) #{'cherry', 'apple', 'banana'} ,duplicates will be ignored

# TRUE AND 1 IS CONSIDERED SAME VALUE
thisset1={"apple", "banana", "cherry", True, 1, 2}
print(thisset1)#{True, 2, 'cherry', 'apple', 'banana'}

#False AND 0 CONSIDERED AS SAME VALUE
thisset2= {"apple", "banana", "cherry", False, True, 0}
print(thisset2) #{False, True, 'cherry', 'apple', 'banana'}
print(len(thisset2)) #5
print(type(thisset2)) #<class 'set'>
#%%
#ACCESS ITEMS:
# u cnn't access items in set by index, but can loop through set# t
set = {"apple", "banana", "cherry"}
for x in set:
print(x) #cherry apple banana one by one

#check if banana is present or not
print("banana" in set) # True
print("banana" not in set) #False

#CHANGE ITEMS: ONCE A SET IS CREATED , YOU CAN NOT CHANGE ITS ITEMS BUT U CAN ADD NEW ITEMS
#TO add one item in set use the add() method

set1 = {"apple", "banana", "cherry"}
set1.add("kiwi")
print(set1) #{'cherry', 'kiwi', 'apple', 'banana'}
#%%
#ADD SET: to add items from another set to current set use , update() method
set2 = {"apple", "banana", "cherry"}
set3 = {"kiwi",1,2}
set2.update(set3)
print(set2)  #{'kiwi', 2, 1, 'cherry', 'apple', 'banana'}

#add any iterable using update() method
setA = {"apple", "banana", "cherry"}
setB = ["kiwi",1,2]
setA.update(setB)#'kiwi', 2, 1, 'cherry', 'apple', 'banana'}
print(setA)

setc = {"apple", "banana", "cherry"}
setc.remove("apple")
print(setc) #{'cherry', 'banana'}

setd = {"apple", "banana", "cherry"}
setd.discard("apple")
print(setd) #{'cherry', 'banana'}
#Note: If the item to remove does not exist, discard() will NOT raise an error.

#%%
#Remove random item by using pop() method
thisset = {"apple", "banana", "cherry"}
x = thisset.pop()
print(x)
print(thisset)#{'apple', 'banana'}

# the clear() method empties the set
thisset1 = {"apple", "banana", "cherry"}
thisset1.clear()
print(thisset1) #set()

#del keyword delete set completely
setd = {"apple", "banana", "cherry"}
del setd
print(setd)

#%%
#loop items
thisset = {"apple", "banana", "cherry"}
for x in thisset:
  print(x) # cherry apple banana one by ones_like

#%%
#JOIN SETS:
#To join sets:

#union() & update() method joins all items from both the sets

set1 = {"a", "b", "c"}
set2 = {1, 2, 3}
set3 = {"John", "Elena"}
set4 = {"apple", "bananas", "cherry"}
set5= {"a", "c", "bananas", "john"}

myset = set1.union(set2, set3, set4 )
print(myset) #{'John', 1, 2, 'c', 3, 'Elena', 'bananas', 'b', 'a', 'john'}
# donn't allows duplicate records

set1.update(set2, set3, set4 ) #its update method no need to store in varible otherwise shows o/p none
print(set1) #{'John', 1, 2, 'c', 3, 'Elena', 'bananas', 'b', 'a', 'john'} , update() changes the original set does not return new set

# '|' this operator use instead of join,allows u to join set with set only not with other datatypes
myset1 = set1 | set2 | set3 | set4
print(myset1) #{'John', 1, 2, 'c', 3, 'Elena', 'bananas', 'b', 'a', 'john'}

#union() method allows u to join set with tuple and other datatypes

set5 = ("kiwi","melon",1,9)
myset3 =set2.union(set5)
print(myset3)  #{1, 2, 3, 'kiwi', 'melon', 9}

#%%
#INTERSECTION(): METHOD RETURNS THE NEW SET THAT ONLY CONTAINS THE ITEMS THAT ARE PRESENT IN BOTH SETS

set1 = {"a", "b", "c"}
set2 = {1, 2, 3}
set3 = {"John", "Elena"}
set4 = {"apple", "bananas", "cherry"}
set5= {"a", "c", "bananas", "john"}

myset4 = set1.intersection(set1,set2,set3,set4)
print(myset4)  # it works for only two sets o/p: set()

myset5 = set1.intersection(set5)
print(myset5)  #{'c', 'a'}

myset6 = set1 & set5
print(myset5) #{'c', 'a'} , allows u to join sets with set not with other datatype

set4.intersection_update(set5)
print(set4) #{'bananas'}

#DIFFERENCE BETWEEN JOIN AND UPDATE:
#‚úÖ update() modifies the original collection, while join() creates and returns a new string.

#%%
set1 = {"apple", 1,  "banana", 0, "cherry"}
set2 = {False, "google", 1, "apple", 2, True}
set3 = set1.intersection(set2)
print(set3) #{False, 1, 'apple'} ,The values True and 1 are considered the same value. The same goes for False and 0.

#%%
#DIFFERENCE(): RETURN A NEW SET THAT WILL CONTAINS ONLY THE ITEMS FROM THE FIRST SET THAT ARE NOT PRESENT IN SECOND SET
set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}
set3 = set1.difference(set2) #{'cherry', 'banana'}, ONLY Different items from set 1 will be output
print(set3)

# also we can use - to join two sets

set4 = set2 - set1 # any operators allows us to join set with sets not with other data types
print(set4)  #{'microsoft', 'google'} used set2 first so different values from set2 gets

#Difference_update(): it will change the original set instead of returning new set
set1.difference_update(set2)
print(set1) #{'cherry', 'banana'}

#%%
#SYMMETRIC_DIFFERENCES(): KEEPS only the elements that are not present in BOTH SETS

set1 = {"apple", "banana", "cherry"}
set2 = {"google", "microsoft", "apple"}
set3 = set1.symmetric_difference(set2)
print(set3) #{'google', 'cherry', 'banana', 'microsoft'}

set4 = set1 ^ set2 #operstor allows u to join two sets not set with any datatypes
print(set4)  #{'google', 'cherry', 'banana', 'microsoft'}

set1.symmetric_difference_update(set2)
print(set1) #{'google', 'cherry', 'banana', 'microsoft'}

#%%
#PYTHON FROZENSET:frozenset is an immutable version of a set(mutable)
x = frozenset({"apple", "banana", "cherry"})
print(x) #frozenset({'cherry', 'apple', 'banana'})
print(type(x)) #<class 'frozenset'>

s = {1, 2, 3}
s.add(4)       # allowed
print(s)       # {1, 2, 3, 4}

fs = frozenset({1, 2, 3})
fs.add(4)     # ‚ùå ERROR ‚Äì cannot add
print(fs)
#frozenset = a set that cannot be changed after creation.
#Normal set (mutable ‚Üí can change):
#Frozenset (immutable ‚Üí cannot change):

#some methods : copy(),diffeence(),intersectin(),isdisjoint(),issubset(),symmetric_difference(),union()
#%%
#PYTHON DICTIONARY: it used to store data values in key:value pairs
#Dictionary items are ordered, changeable, and do not allow duplicates.
thisdict = {
   "brand" : "ford",
   "model" : "car",
   "color" : "red"
}
print(thisdict)  #{'brand': 'ford', 'model': 'car', 'color': 'red'}

# print brand value of dictionary
print(thisdict["brand"])#ford
print(thisdict["color"]) #red
print(thisdict["model"]) #car

#As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.
#But still, you cannot get items by index
#ORDERED: python remembers the sequence of items
#UNORDERED: Python does not remember sequence
#but dictionaries never support index access
#DUPLICATES NOT ALLOWD: dict can not have two items with the same key
#%%
dict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "year": 2020 # Duplicate values overwrite existing value
}
print(dict) #{'brand': 'Ford', 'model': 'Mustang', 'year': 2020}
print(len(dict)) #3 duplicates overwrite so considers 3 values as two keys are same
print(type(dict))  #<class 'dict'>

#DICT ITEMS - DATA TYPES : STR,INT,BOOL AND LIST DATA TYPES
dict1= {
  "brand": "Ford",
  "electric": False,
  "year": 1964,
  "colors": ["red", "white", "blue"]
}
print(dict1) #{'brand': 'Ford', 'electric': False, 'year': 1964, 'colors': ['red', 'white', 'blue']}
'''
#THE dict() constructor
thisdict = dict(name = "John", age = 36, country = "Norway")
print(thisdict) #{'name': 'John', 'age': 36, 'country': 'Norway'}'''

# %%
#PYTHON IF STATEMENT
a = 33
b = 200
if a < b:
    print("a is less than b")#

#%%
#checking if a number is positive
number = 15
if number > 0:
  print("number is positive") #number is positive

#%%
#MULTIPLE STATEMENTS IN IF BLOCK
age = 30
if age >= 18:
    print("you are an adult")
    print("you can vote")
    print("you have a full legal rights")

#%%
#USING VARIABLES IN CONDITIONS
is_logged_in = True
if is_logged_in:
    print("you are logged in") #you are logged in
#any non empty string "False" is considered as True

#%%
#elif : keyword is python's way of saying " if the previous conditions were not True , then try this condition
a = 10
b = 10
if a > b:
    print("a is greater than b")
elif a == b:
    print("a is equal to b")

#%%
#MULTIPLE elif STATEMENTS:You can have as many elif statements as you need. Python will check each condition in order
# and execute the first one that is true.

score = 70
if score >= 90:
    print("Grade :A")
elif score >= 80:
    print("Grade :B")
elif score >= 70:
    print("Grade :C")
elif score >= 60:
    print("Grade :D") #Grade :C

#%%
# HOW elif WORKS: python evaliuates conditions from top to bottom , as soon as a condition that is true
# it executes that block and skips all remaining conditions

#IMPORTANT: only the FIRST TRUE condition will be executed. even if multiple conditions are true
#python stops after executing the first matching block
age = 25

if age < 13:
  print("You are a child")
elif age < 20:
  print("You are a teenager")
elif age < 65:
  print("You are an adult")
elif age >= 65:
  print("You are a senior")

#%%
#ELSE KEYWORD: else keyword catches anything which isn't caught by presseding conditions
#the else statement is executed when if condition( & any elif conditions) evaluate to False

a = 200
b = 100
if a < b:
    print("a is less than b")
elif  a == b:
    print("a is equal to b")
else :
    print("a is greater than b")

#%%
# else without elif, Note: The else statement must come last. You cannot have an elif after an else.
a = 200
b = 100
if a < b:
    print("a is less than b")
else:
    print("a is greater than b")

#%%
#checking even or odd numbers
number = 7
if number % 2 == 0:
    print("even number")
else:
    print("odd number")

#%%
#Complete if-elif-else chain
temp = 22
if temp >30:
    print("It's hot outside")
elif temp >20:
    print("it's warm outside")
elif temp >10:
    print("it's cold outside")
else:
    print("it's bad outside")

#%%
#else as Fallback: this makes it useful for error handling,validation and providing default values
username = "Vedanti"
if len(username) > 0 :
    print("username is greater than 0")
else:
    print("Error : Username cannot be empty")

#%%
#PYTHON SHORTHAND IF: if u have only one statement to execute, u can put it on same line as if statement
#one line if statement
a = 5
b = 2
if a > b: print("a is greater than b")

#%%
#CONDITIONAL EXPRESSION/ TERNARY OPERATOR (ONE-LINE IF/ELSE that prints value)
a = 2
b = 330
print("A") if a > b else print("B")

#%%
#The AND operator: both conditions must be true for the entire expressions to be True
a = 200
b = 330
c = 500
if c > a and c > b :
    print("both conditions are true")

#%%
#The OR Operator: At least one condition must be true for the entire expression to be true.
a = 200
b = 330
c = 500
if c > a or c < b:
    print("At least one condition is True")

#%%
#THE NOT OPERATOR: used to reverse the result of the conditional statement.
A = 30
B = 200
if not A > B :
    print("A is NOT greater than B")

#%%
#USER AUTHENTICATION CHECK:
username = "Vedanti"
password = "Vedashree"
is_verified =  True

if username and password and is_verified:
    print("Login successful")
else:
    print("Login failed")

#%%
#python nested if: you can have if statements inside if statements. this is called nested if statements
x = 41
if x > 10:
    print("x is above ten")
    if x > 20:
        print("x is above twenty")
    else:
        print("x is not above 20")
# o/p:x is above ten,x is above twenty one by one

#%%
#How NESTED IF WORKS: each level of nesting creates a deeper level of decision-making.
#The code evaluates from the outermost condition inward (in below change age and get diff. o/p)

age = 24 # 10, 18
has_license = True

if age >=18:
    if has_license:
      print("you can drive")
    else:
      print("you need license")
else:
    print("you are too young to drive")

#%%
#LOGIN VALIDATION WITH NESTED CHECKS(it runs outer staement first and then inner )
username = "Vedanti"
password = "Vedashree"
is_active = True

if username:
    if password:
        if is_active:
            print("login successful")
        else:
            print("Accpount is not active")
    else:
        print("password required")
else:
    print("username required")

#%%
#python pass statement:if statement can not be empty ,but you for some reason have an if statement with no content
# put in the pass(Do Nothing) statement to avoid getting an error
a = 33
b = 80
if b > a:
    pass # having an empty if statement like this, would raise an error without the pass statement

# Why use PASS statement: if u r creating code structure but haven't implemented logic yet,
#2.use as a placeholder for future code during development
#3.when statement is required syntactically but no action is needed

#DIFFERENCE BETWEEN PASS and COMMENTS:
# A comment is ignored by python, but pass is an actual statement that gets executed.
# you need pass where python expects a statement not just a comment

#%%
score = 85
if score > 90: # When run this two lines,This will raise an error
  pass # This is excellent this will not raise any error
print("score processed") #o/o: score processed (not showing indentation error)

#%% python has two while and for primitive commands/main loop commands),
#WHILE LOOPS:with while loop we can execute a set of statements as long as a condition is true

i = 1
while i < 10:
    print(i) # o/p : 1...9  one by one
    i = i + 1 # remember to increment i or else loop will continue forever( i += 1)

#%%
# THE BREAK STATEMENT: we can stop the loop even if the while condition IS True
i = 1
while i < 7:
    print(i)
    if i == 5:
        break  # o/p : 1...5 one by one
    i += 1 #The loop prints numbers from 1 to 5, but it stops at 5 because break stops the loop immediately.
#%%
#THE CONTINUE STATEMENT: with the continue statement we can stop the current iteration , and continue with rest
i = 0
while i < 6:
  i += 1      # when we use while need to increment before starting if statement
  if i == 3:
    continue
  print(i) # o/p: 1 2 4 5 7 one by one(3 skips as i==3 and then continue)

'''
i = 2
i += 1 ‚Üí i becomes 3
Is i == 3? ‚Üí YES
continue happens
üëâ Skip the print(i)
üëâ Don‚Äôt print 3
üëâ Go to next iteration
(No output here)'''

#%%
#THE ELSE STATEMENT: with the else statement we can run a block of code once when the condition is False or no longer True

i = 1
while i < 10:
    print(i)
    i += 1 # at 9th output 10<10 becomes false
else:
    print("i is no longer less than 6") #1..9 one by one , at 10th place  i is no longer less than 9

#%%
# for loop BREAK

fruits = ["apple", "banana", "cherry"]
for x in fruits:
   print(x)
   if x == "banana": # break comes after the print
       break       # apple banana will be o/p break at banana stops looping

#%%
fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    break
  print(x) # o/p:apple break comes before the print

#%%
fruits = ["apple", "banana", "cherry"]
for x in fruits:
    if x == "banana":
        continue
    print(x) # apple cherry (skipped banana and continue loop)

#%%
#THE range() Function
for x in range(10):
    print(x) # 0..9 one by one

#it is possible to specify the starting value by adding a parameter:range(2,10)
for x in range(2,10):
    print(x) #2..9 not including 10 bcz starts from 0

#increment the sequence by 3(default is 1)
for x in range(2,10,3):
    print(x) # 2 5 8


#%%
#MATCH STATEMENT: used to perform different actions based on different condition,instead of writing many if.
#else statements, you can use the match statement,The match statement selects one of many blocks to be executed
#SYNTAX:
match expression:
    case x:
        code block
    case y:
        code block
    code z:
        code block

#%%
#If-else = use for conditions(ideal:complex logic,many fixed options: looks messy, introduced:always existed
#Match = use for fixed choices(check:exact pattern/values,not ideal:complex logic,introduced:python3.10,clean readable)

day = 4
match day:
    case 1:
        print("Monday")
    case 2:
        print("Tuesday")
    case 3:
        print("Wednesday")
    case 4:
        print("Thursday")
    case 5:
        print("Friday")
    case 6:
        print("Saturday")
    case 7:
        print("Sunday")  #o/p :Thursday
#%%
#DEFAULT VALUE: USE _ character as the last case value if you want a code block to execute ehen thjere are not other matches

day = 4
match day:
    case 6:
        print("Sunday")
    case 7:
        print("Monday")
    case _:
        print("Looking forward to the weekends") #o/p:Looking forward to the weekends

#%%
#COMBINE VALUES: use the PIPE | character as an OR operator in the case evaluation to check more than one value match in one case:
day = 4
match day:
    case 1 | 2 | 3 | 4 | 5 :
        print("Today is weekday")
    case 6 | 7:
        print("Today is weekend") #o/p: Today is weekday

#%%
#if statements as a guards: we can add if statements in the case evaluation as an extra condition check:

month = 5
day = 4
match day:
    case 1 | 2| 3| 4| 5 if month ==4:
        print(" A weekday in April")
    case 1 | 2| 3| 4| 5 if month ==5:
        print(" A weekday in May")
    case _:                           #space needs case _
        print("no match") # a weekday in may

#%%
#Else in for loop using range function
#print all numbers from 0 to 4 , and print a message when the loops has ended
for x in range(5):
    print(x)
else:
    print("finally finished")

#%%
# The else block will not be executed if the loop is stopped by a break statement
for x in range(5):
    if x==3:
        break
    print(x)
else:
    print("finally finished") #o/p: 0 1 2 one by one

# %%
#PYTHON ARRAYS: python does not have built in support for arrays,but python list can be used instead
#Note; this page shows you how to use LISTS as ARRAYS, however, to work with arrays in python you will have
#to import library like NumPy library
#create an array containing car names

cars = ["ford","volvo","BMW"] #it looks just like LIst and LL methods are same as list
x = cars[0] # 'ford' , access the elements of an Array
print(x)

cars[0] = 'toyoto'
print(cars[0]) #modify the value of the first array item

x =len(cars)
print(x) #3

for x in cars:
    print(x) #looping array element, toyoto volvo BMW

cars.append("Honda")
print(cars) #to add an element to the cars ['toyoto', 'volvo', 'BMW', 'Honda']

cars.pop(1) # remove an element from the array
print(cars) #['toyoto', 'BMW', 'Honda']

cars.remove("Ford") #remove element from array without using indexing
print(cars) #If a list has the same value multiple times,remove() will delete only the first one, not all.

'''
| Feature                     | **List**            | **Array**          |
| --------------------------- | ------------------- | ------------------ |
| Stores different data types | ‚úÖ Yes               | ‚ùå No               |
| More common in Python       | ‚úÖ Yes               | ‚ùå Less common      |
| Faster for numeric work     | ‚ùå No                | ‚úÖ Yes              |
| Memory usage                | High                | Low                |
| Best use case               | General programming | Math, data science |

Syntax;

Array (NumPy):
import numpy as np
arr = np.array([10, 20, 30])
print(arr)

my_list = [10, 20, 30]
'''

#%%
'''ITERATOR :üß† So in super simple words:Iterator is a step-by-step value picker
An iterator =
üëâ A special object that gives one value at a time
üëâ It has two hidden functions inside it:
__iter__() = makes the iterator
__next__() = gives next value

difference between iterator and iterable
‚úî Iterable stores the items
‚ùå Iterable does not give items one by one by itself

Iterable:‚ÄúA collection that can give you an iterator.‚Äù
Iterator:‚ÄúAn object that gives one item at a time using next().‚Äù

üîç Super Easy Real-Life Example
üì¶ Iterable = A box with 5 chocolates,You open the box, all chocolates are inside.
Iterator = Your hand picking chocolates,You take out one, next, next...'''

numbers = [10 , 20 , 30]
iterator = iter(numbers)# __iter__() runs in background, it creates or returns iterator objects
print(next(iterator)) #__next__() gives 10, gives next value each time u called it
print(next(iterator)) #20
print(next(iterator)) #30

#%%
#even strings are iterable objects, containing a sequence of charecter

mystr = "banana"
myit = iter(mystr)
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))  #0/p: b a n a n a
print(next(myit)) #want to again print but there are not any extra character remaining so shows error:StopIteration

''' You don‚Äôt write StopIteration yourself normally ‚Äî Python raises it automatically.
But if you want to handle it safely, you must use try‚Äìexcept.'''
#%%
mystr = "banana"
myitr = iter(mystr) #Think of it as a finger pointing at the first letter.

while True: #‚ÄúKeep doing this forever, unless I stop you.‚Äù
    try:#Inside the loop: try‚Äìexcept ,tries to print next letter first time b ,second time a n...a
        print(next(myit)) #after printing all 6 items nothing is left so raise error
    except StopIteration: #This catches the error and stops the loop safely.
        print("No more character left ") # o/p :No more character left
        break #Then break stops the infinite loop.

#%%
#looping through an iterator:
mytuple = ("apple", "banana", "cherry")
for x in mytuple:
    print(x) #o/p: apple banana cherry

#iterate the character of str
str ="banana"
for x in str:
    print(x) # b a n a n a

#%%
#Module: it's a simple file that contains python code, it can have functions, variables, classes , loops, logic, and u
#can reuse this code in another python file using import

#imagine you write a file named math_tools.py
def add(a,b):
    return a+b
#this is called a module
#now in another python file:
#%%
import math_tools
print(math_tools.add(28,20)) # o/p: 48
#USEFUL:your module's code is reused,write once use anywhere,keep code organised, easy to maintain:fix bug in one module

#%%
#Re-naming a module: You can create an alias when you import a module , by using as keyword
import math_tools as mx

print(mx.add(20,50))


#BUILT-IN-MODULE:import
#The **`platform`** module in Python is a **built-in module** that gives information about the **computer system**,
# **operating system**, **Python version**, and **hardware details**.
#It is commonly used when you want your program to know **where it is running**.
# üß© **Python `platform` Module (Built-in) ‚Äî Easy Explanation**
'''Think of the **platform module** as a tool that tells Python:‚ÄúWhich system am I running on?‚Äù
It helps you get info like:
* Windows / Linux / macOS
* Python version
* Processor / architecture (32-bit or 64-bit)
* System details

# üìå **Why is it useful?** You use this module when:
* You want OS-specific behavior
  Example: Do one thing on Windows and another on Linux.
* Debugging system issues
* Creating setup scripts
* Checking compatibility of Python packages
# üîç **Common Functions of `platform` Module (with examples)**'''

#%%
### ‚úî 1. **platform.system()**: Returns the operating system name.
import platform
print(platform.system()) # o/p:Windows

#%%
### ‚úî 2. **platform.release()** :Gives the OS version.
print(platform.release()) #11

#%%
# ‚úî 3. **platform.version()** :More detailed OS version info.
print(platform.version()) #10.0.22631

#%%
### ‚úî 4. **platform.machine()**: Returns hardware type (processor architecture).
print(platform.machine()) #AMD64

#%%
### ‚úî 5. **platform.python_version()** :Returns Python version as a string.
print(platform.python_version()) #3.13.5

#%%
## ‚úî 6. **platform.platform()**: Returns a combined summary string.
print(platform.platform()) #Windows-11-10.0.22631-SP0

# üß† **One-line definition**:platform` module helps Python identify the system and environment it is running on.**

#%%
#using dir() function:There is a built-in function to list all the function names (or variable names) in a module
import platform
print(dir(platform)) #['AndroidVer', 'IOSVersionInfo', '_Processor', '_WIN32_CLIENT_RELEASES', '_WIN32_SERVER_RELEASES'
# , '__builtins__', '__cached__', '__copyright__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '__version__', '_comparable_version', '_default_architecture', '_follow_symlinks', '_get_machine_win32', '_java_getprop', '_mac_ver_xml', '_node', '_norm_version', '_os_release_cache', '_os_release_candidates', '_parse_os_release', '_platform', '_platform_cache', '_sys_version', '_sys_version_cache', '_syscmd_file', '_syscmd_ver', '_uname_cache', '_unknown_as_blank', '_ver_stages', '_win32_ver', '_wmi', '_wmi_query', 'android_ver', 'architecture', 'collections', 'freedesktop_os_release', 'functools', 'ios_ver', 'itertools', 'java_ver', 'libc_ver', 'mac_ver', 'machine', 'node', 'os', 'platform', 'processor', 'python_branch', 'python_build', 'python_compiler', 'python_implementation', 'python_revision', 'python_version', 'python_version_tuple', 're', 'release', 'sys', 'system', 'system_alias', 'uname', 'uname_result', 'version', 'win32_edition', 'win32_is_iot', 'win32_ver']

#import PART FROM MODULE:we can import only parts from module by using 'from' keyword
# the module named mymodule has one function and one dict
def greeting(name):
  print("Hello, " + name)

person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}

#import only the person1 dict from the module
from mymodule import person1
print(person1["age"])

#Note: When importing using the from keyword, do not use the module name when referring to elements in the module.
# Example: person1["age"], not mymodule.person1["age"]

#%%
#python dates: a date in python is not a data type of it's own,but we can import moduledatetime to work with dates
import datetime #The date contains year, month, day, hour, minute, second, and microsecond.
print(datetime.datetime.now()) #2025-12-07 13:09:51.408648
print(datetime.datetime.today()) #2025-12-07 13:09:51.408648
print(datetime.datetime.today().date()) #2025-12-07
print(datetime.datetime.today().time()) #13:23:11.345341

#%%
#return the year and name of weekday:
import datetime
x = datetime.datetime.now()
print(x.year) #2025
print(x.month)#12
print(x.day)#7
print(x.hour)#13
print(x.minute)#28
print(x.second)#42
print(x.microsecond)#464553
print(x.strftime("%A"))#Sunday
#strftime() = ‚Äúformat this date in the style I want‚Äù
#üëâ "%A" = ‚Äúgive me the weekday name‚Äù
#starftime() : used with a date or time object(like datetime.now()) to format date and time in readable str
#think of it like converting a date into a specific text format

#%%
import datetime
x = datetime.datetime(2024, 7, 9)
print(x.strftime("%A"))#Tuesday (strftime("%A") always prints the day name of the date stored in x.)
print(x.strftime("%a")) #Tue
print(x.strftime("%B")) #july (month name full version)
print(x.strftime("%b")) #jul (month name short version)
print(x.strftime("%w")) #2 (sunday=0,mon=1,tue=3...)
print(x.strftime("%d")) #09 (day of month)
print(x.strftime("%m")) #07 (month as number)
print(x.strftime("%y")) #24 (year short version eithout century)
print(x.strftime("%Y")) #2024 (year full version)

#%%
#python math FUNCTIONS: python has set of built in math functions,including an extensive module,that allows you to perform
# mathematical tasks on numbers: min() ,max() functions used to find the lowest or highest value in iterable
x = min(55,28,1)
y = max(55,28,1)
print(x)#:1
print(y)#:55

#the abs() returns the absolute value of  the specified number
z = abs(-4.56)
print(z) #4.56

#the pow(x,y) functions returns the value of x to the power of y(x^y)
a = pow(2,3)
print(a)  # 8(2*2*2)

#%%
#MATH MODULES:
import math
print(math.sqrt(64)) #o/p:8.0 (sqrt:square root)
print(math.ceil(1.4)) # 2 :The math.ceil() method rounds a number upwards(ceil:cealing)to its nearest integer
print(math.floor(1.4)) # 1 :math.floor() method rounds a number downwards(floor) to its nearest intege
print(math.pi) #3.141592653589793

#CONVERT FROM JSON TO PYTHON:json.loads(x)
#parse JSON:syntax for storing and exchanging data, python has built in package called JSON,which helps to work DATA
import json
x =  '{ "name":"John", "age":30, "city":"New York"}'#(json:contains key value paired data)
y = json.loads(x) #parse x :read data + understand its structure + convert it into a usable format in python
print(y) #{'name': 'John', 'age': 30, 'city': 'New York'}
print(type(y))  #<class 'dict'>
print(y["city"]) #New York

#%%
#CONVERT FROM PYTHON TO JSON: json.dumps()
import json
x = { "name":"John", "age":30, "city":"New York"}
y = json.dumps(x) #convert into json
print(y) #{"name": "John", "age": 30, "city": "New York"}

#%%
import json

print(json.dumps({"name": "John", "age": 30})) # {"name": "John", "age": 30} convert python object json str
print(json.dumps(["apple", "bananas"])) #["apple", "bananas"] :array
print(json.dumps(("apple", "bananas"))) #["apple", "bananas"] :array
print(json.dumps("hello")) # "hello"
print(json.dumps(42)) # 42
print(json.dumps(31.76)) #31,76
print(json.dumps(True)) #true
print(json.dumps(False)) #false
print(json.dumps(None)) #null

#%%
#convert the python object containing all the legal data types:
import json

x = {
  "name": "John",
  "age": 30,
  "married": True,
  "divorced": False,
  "children": ("Ann","Billy"),
  "pets": None,
  "cars": [
    {"model": "BMW 230", "mpg": 27.5},
    {"model": "Ford Edge", "mpg": 24.1}
  ]
}
print(json.dumps(x))  #{"name": "John", "age": 30, "married": true, "divorced": false, "children": ["Ann", "Billy"],
# "pets": null, "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}]}

#%%
#FORMAT THE RESULT: above prints  a json string,but it is not easy to read,with no indentations and line breaks
#json.dumps() method has parameters to make it easier to read the result
# use indent parameter to define the numbers of indents:
import json

x = {
  "name": "John",
  "age": 30,
  "married": True,
  "divorced": False,
  "children": ("Ann","Billy"),
  "pets": None,
  "cars": [
    {"model": "BMW 230", "mpg": 27.5},
    {"model": "Ford Edge", "mpg": 24.1}
  ]
}
print(json.dumps(x, indent =4))

'''
o/p:
{
    "name": "John",
    "age": 30,
    "married": true,
    "divorced": false,
    "children": [
        "Ann",
        "Billy"
    ],
    "pets": null,
    "cars": [
        {
            "model": "BMW 230",
            "mpg": 27.5
        },
        {
            "model": "Ford Edge",
            "mpg": 24.1
        }
    ]
}
'''

#%%
#USE SEPARATORS parameter to change the default separator:You can also define the separators, default value is
# (", ", ": "), which means using a comma and a space to separate each object, and a colon and a space to separate
# keys from values

import json

x = {
  "name": "John",
  "age": 30,
  "married": True,
  "divorced": False,
  "children": ("Ann","Billy"),
  "pets": None,
  "cars": [
    {"model": "BMW 230", "mpg": 27.5},
    {"model": "Ford Edge", "mpg": 24.1}
  ]
}
print(json.dumps(x, indent =4 ,separators = (". ", " = ")))

'''
o/p"
{
    "name" = "John". 
    "age" = 30. 
    "married" = true. 
    "divorced" = false. 
    "children" = [
        "Ann". 
        "Billy"
    ]. 
    "pets" = null. 
    "cars" = [
        {
            "model" = "BMW 230". 
            "mpg" = 27.5
        }. 
        {
            "model" = "Ford Edge". 
            "mpg" = 24.1
        }
    ]
}
'''
#%%
# USE the sort_keys parameter to specify if the result should be sorted or not
import json

x = {
  "name": "John",
  "age": 30,
  "married": True,
  "divorced": False,
  "children": ("Ann","Billy"),
  "pets": None,
  "cars": [
    {"model": "BMW 230", "mpg": 27.5},
    {"model": "Ford Edge", "mpg": 24.1}
  ]
}

print(json.dumps(x, indent=4, sort_keys=True))

'''
O/P:
{
    "age": 30,
    "cars": [
        {
            "model": "BMW 230",
            "mpg": 27.5
        },
        {
            "model": "Ford Edge",
            "mpg": 24.1
        }
    ],
    "children": [
        "Ann",
        "Billy"
    ],
    "divorced": false,
    "married": true,
    "name": "John",
    "pets": null
}
 '''

'''
üî• Super-short difference
indent=4 ‚Üí Pretty JSON
separators ‚Üí Custom symbols replacing , and :
sort_keys=True ‚Üí Alphabetical order

‚úÖ 1. json.dumps(x, indent=4)
‚úî Makes JSON pretty / readable by adding 4-space indentation.
‚úî Only formatting, nothing else changes.

‚úÖ 2. json.dumps(x, indent=4, separators=(". ", " = "))
‚úî Changes separators used between items.
Instead of default , and :, it uses
". " between items
" = " between key & value
‚úî Output looks custom formatted (not normal JSON).

‚úÖ 3. json.dumps(x, indent=4, sort_keys=True)
‚úî Sorts keys in alphabetical order before converting to JSON.
‚úî Useful for clean, organized output.
'''


#Regex:
# Regex (Regular Expression) is like a **smart search tool** that can find **specific patterns** inside text.
'''You can find:
‚úî words
‚úî numbers
‚úî emails
‚úî phone numbers
‚úî dates
‚úî any custom pattern

Think of regex as **searching with rules**, not just exact words.'''

#%%
# üü¢ **Example 1: Find all words**
import re
text = "Python is super easy"
result = re.findall(r"[A-Za-z]+", text)
print(result) #['Python', 'is', 'super', 'easy']
# `[A-Za-z]+` ‚Üí match letters (words)

# üü¢ **Example 2: Find all numbers**
import re
text = "I bought 2 apples and 5 bananas"
result = re.findall(r"\d+", text)
print(result) #['2', '5']
# `\d+` ‚Üí match digits

# üü¢ **Example 3: Find an email**
import re
text = "Contact me at rupali123@gmail.com"
result = re.findall(r"[a-zA-Z0-9._]+@[a-zA-Z]+\.[a-zA-Z]+", text)
print(result) #['rupali123@gmail.com']
#Pattern checks email format.

# üü¢ **Example 4: Find a phone number (10-digit)**
import re
text = "My number is 9876543210"
result = re.findall(r"\b\d{10}\b", text)
print(result) #['9876543210']
# `\d{10}` ‚Üí exactly 10 digits
# `\b` ‚Üí word boundary (complete number)

# üü¢ **Example 5: Find a date (dd/mm/yyyy)**
import re
text = "Today's date is 07/12/2025"
result = re.findall(r"\d{2}/\d{2}/\d{4}", text)
print(result) #['07/12/2025']
# Pattern matches **2 digits / 2 digits / 4 digits**

# üü¢ **Example 6: Find any pattern (e.g., words starting with P)**
import re
text = "Python is Powerful and Popular"
result = re.findall(r"\bP\w+", text)
print(result) #['Python', 'Powerful', 'Popular']
# `P\w+` ‚Üí words that start with **P**
#Return an empty list if no match was found:

#%%
#Search the string to see if it starts with "The" and ends with "Spain":
import re
txt = "The rain in spain"
x= re.search("^The.*spain$", txt)
if x:
  print("YES! We have a match!")
else:
  print("No match") #YES! We have a match!
'''
^The.*spain$
‚úî Starts with The : ^
‚úî Middle part is rain in : .* 
‚úî Ends with Spain : $
'''

#%%
#findall() : returns a LIST containing all matches
import re
txt = "The rain in spain"
print(re.findall("ai", txt)) #['ai', 'ai']
print(re.findall("me",txt)) #[] empty list will be output

#%%
#search() : searches str for matches, if there are more match  ony first occurence will be returned
import re
txt = "The rain in spain"
x = re.search("\s", txt)
y = re.search("\s", txt)#\s : str contains white spaces, \S: does not contain white space charecter
print(x.start()) # 3 as first space found at 3rd index, if no matches value: NONE
print(y.start()) #3

#%%
#split() : returns a list where the str has been split at each match
#split at each white space character
import re
txt = "The rain in spain"
x = re.split("\s",txt)
print(x)  #['The', 'rain', 'in', 'spain']

# u can control the number of occurrences by specifying the maxsplit() parameter
import re
txt = "The rain in spain"
x = re.split("\s",txt ,1)
print(x)  #['The', 'rain in spain']
import re

#sub()  :replaces the matches with the text of your choice
#replace every white space character with the number 9
y =re.sub("\s","9",txt)
print(y)  #The9rain9in9spain


'''
.span() returns a tuple containing the start-, and end positions of the match.
.string()returns the string passed into the function
.group() returns the part of the string where there was a match'''
#%%
import re

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt) #\bS\w+ ‚Üí find a word starting with S
print(x) #.span() ‚Üí gives start and end positions ‚Üí (12, 17)
#print(x.span()) #(12, 17)

#%%
import re

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.string) #The rain in Spain

#%%
import re

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.group()) #Spain(The regular expression looks for any words that starts with an upper case "S":)

#PIP : PIP Installs Packages OR Preferred installer program
#PIP is a tool in Python used to install, upgrade, and manage external libraries (packages) that are not
#included in Python by default. OR PIP is a package manager for Python modules
'''
üëâ PIP = Python's App Store Installer (here we are considering python like a mobile phone)
Using pip, you can install extra packages like:
numpy (for maths) #pip install numpy
pandas (for data)
flask (for web apps)
requests (for APIs)
PIP LIST: TO LIST ALL PACKAGES IN PYHON
'''

#difference between module, packages and library
'''
Module ‚Üí A single Python file containing code (e.g., math.py).
Package ‚Üí A folder containing multiple modules, plus an __init__.py file.
Library ‚Üí A collection of packages and modules that provide specific functionality (e.g., NumPy).
'''

#TRY EXCEPT:
'''
‚úî try:(block)
Try doing something
‚û°Ô∏è ‚ÄúTry to open the chocolate‚Äù
‚úî except:
If something goes wrong, handle the error
‚û°Ô∏è ‚ÄúIf the wrapper is too tight and tears your hand, handle the problem‚Äù
‚úî else:
Runs only if no error happens
‚û°Ô∏è ‚ÄúIf the chocolate opened successfully, enjoy eating it!‚Äù
‚úî finally:
Runs always, no matter what happens
‚û°Ô∏è ‚ÄúAfter everything, throw the wrapper in the dustbin (must be done always).‚Äù
'''

#%%
try:
    print(10 / 2)   # Try to run this
except:
    print("Something went wrong!")   # If error happens
else:
    print("No error, code ran successfully!")  # Runs only if no error
finally:
    print("This will run no matter what!")     # Always runs

'''
O/P:5.0
    No error, code ran successfully!
    This will run no matter what!
'''

#EXAMPLE WITH ERROR
#%%
try:
    result = 10 / 0
except:
    print("‚ùå Error: You cannot divide by zero!")
else:
    print("‚úî Division successful:", result)
finally:
    print("üìå Program ended.")
'''
O/P: ‚ùå Error: You cannot divide by zero!
    üìå Program ended.
'''

























